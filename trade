-- Advanced Trading (net-income only, 2s delay, 5-unit cap if AI not producing, special Consumer Goods rule)

print("=== Advanced Trading script loaded ===")

-- Obsidian UI setup
local Library = loadstring(game:HttpGet(
    "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/Library.lua"
))()
local Window = Library:CreateWindow({
    Title         = "Advanced Trading",
    Footer        = "v1.0.0",
    ToggleKeybind = Enum.KeyCode.RightControl,
    Center        = true,
    AutoShow      = true,
})

-- Trading tab & settings
local TradingTab    = Window:AddTab("Trading", "shopping-cart", "Automated resource trading")
local SettingsGroup = TradingTab:AddLeftGroupbox("Auto-Trade Settings", "settings")

-- Populate dropdown from Assets.Resources
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local resourcesFolder   = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Resources")
local resourceNames     = {}
for _, r in ipairs(resourcesFolder:GetChildren()) do
    table.insert(resourceNames, r.Name)
end
table.sort(resourceNames)

local selectedResources = {}
SettingsGroup:AddDropdown("TradeResources", {
    Values   = resourceNames,
    Default  = {},
    Multi    = true,
    Text     = "Select Resources",
    Tooltip  = "Which resources to trade",
    Callback = function(map)
        selectedResources = {}
        for name,on in pairs(map) do
            if on then selectedResources[name] = true end
        end
        local list = {}
        for name in pairs(selectedResources) do
            table.insert(list, name)
        end
        print("Resources selected:", #list > 0 and table.concat(list, ", ") or "none")
    end,
})

-- Enable Auto-Trade toggle
local tradingEnabled = false
SettingsGroup:AddToggle("EnableAutoTrade", {
    Text    = "Enable Auto-Trade",
    Default = false,
    Callback = function(v)
        tradingEnabled = v
        if v then startTrading() else stopTrading() end
    end,
})

-- Services & state
local RunService  = game:GetService("RunService")
local StarterGui  = game:GetService("StarterGui")
local Players     = game:GetService("Players")
local GameManager = workspace:WaitForChild("GameManager")
local player      = Players.LocalPlayer

-- Per-unit sell prices
local ResourcePrices = {
    Iron                = 30400,
    Aluminum            = 30400,
    Oil                 = 32000,
    Phosphate           = 33200,
    Copper              = 33600,
    Chromium            = 38000,
    Gold                = 43200,
    Diamond             = 69600,
    Tungsten            = 76800,
    Titanium            = 81600,
    Uranium             = 420000,
    Steel               = 60000,
    ["Consumer Goods"]  = 65920,
    Fertilizer          = 67200,
    ["Motor Parts"]     = 73600,
    Electronics         = 81600,
    ["Aircraft Parts"]  = 83200,
    ["Enriched Uranium"]= 96000000,
}

-- Constants
local MIN_POST_NET = 1000    -- AI must retain ≥ this net income
local TRADE_DELAY  = 2       -- seconds between each individual trade

-- AI list & heartbeat connection
local aiList, aiIndex, connection

-- Helper: sum direct NumberValue children of a folder
local function sumFolder(folder)
    local total = 0
    for _, v in ipairs(folder:GetChildren()) do
        if v:IsA("NumberValue") then
            total += v.Value
        end
    end
    return total
end

-- AI detection
local function isAICountry(c)
    local l = c:FindFirstChild("Leader")
    return l and l.Value == (c.Name .. "AI")
end

local function getAICountries()
    local list = {}
    for _, c in ipairs(workspace.CountryData:GetChildren()) do
        if isAICountry(c) then
            table.insert(list, c.Name)
        end
    end
    return list
end

-- Sell one resource to one AI, using only net-income and balance checks
local function sellResourceToAI(myCountry, resourceName, aiName)
    local price = ResourcePrices[resourceName]
    if not price then return end

    -- Check AI debt
    local econ = workspace.CountryData:FindFirstChild(aiName):FindFirstChild("Economy")
    if not econ then return end
    local balance = econ:FindFirstChild("Balance") and econ.Balance.Value or 0
    if balance < 0 then return end

    -- Compute AI net income = sum(Revenue) - sum(Expenses)
    local netIncome = 0
    if econ:FindFirstChild("Revenue") then
        netIncome = sumFolder(econ.Revenue)
    end
    if econ:FindFirstChild("Expenses") then
        netIncome -= sumFolder(econ.Expenses)
    end
    if netIncome <= 0 then return end

    -- Determine maximum by net-income
    local estimate = netIncome / price
    local amt = estimate - 1
    if amt <= 0 then return end

    -- If AI no longer produces this resource (flow ≤ 0), cap at 5 units
    local aiResources = workspace.CountryData:FindFirstChild(aiName):FindFirstChild("Resources")
    if aiResources then
        local aiRes = aiResources:FindFirstChild(resourceName)
        if aiRes and aiRes:FindFirstChild("Flow") and aiRes.Flow.Value <= 0
           and resourceName ~= "Consumer Goods" then
            amt = math.min(amt, 5)
        end
    end

    local value = amt * price
    -- Ensure AI retains at least MIN_POST_NET after trade
    if (netIncome - value) < MIN_POST_NET then
        return
    end

    -- Execute trade
    print(("Trading %.4f units of %s to %s for $%.2f (netIncome $%.2f)"):format(
        amt, resourceName, aiName, value, netIncome
    ))
    GameManager.ManageAlliance:FireServer(aiName, "ResourceTrade", {
        resourceName, "Sell", amt, 1, "Trade"
    })

    task.wait(TRADE_DELAY)
end

-- Sell all selected resources to one AI
local function sellAllToAI(myCountry, aiName)
    for resourceName in pairs(selectedResources) do
        sellResourceToAI(myCountry, resourceName, aiName)
    end
end

-- Heartbeat: process one AI per iteration, 2s delay between AIs
local function heartbeat()
    if not tradingEnabled then return end

    -- Find player's country
    local myCountry
    for _, c in ipairs(workspace.CountryData:GetChildren()) do
        if c.Leader and c.Leader.Value == player.Name then
            myCountry = c
            break
        end
    end
    if not myCountry then return end

    -- All AI done?
    if aiIndex > #aiList then
        stopTrading()
        StarterGui:SetCore("SendNotification", {
            Title    = "Trade Complete",
            Text     = "Finished trading with all available AI countries.",
            Duration = 5,
        })
        return
    end

    -- Process this AI
    local aiName = aiList[aiIndex]
    print("► Processing AI:", aiName)
    sellAllToAI(myCountry, aiName)

    aiIndex += 1
    task.wait(TRADE_DELAY)
end

-- Start/stop functions
function startTrading()
    aiList  = getAICountries()
    aiIndex = 1
    if connection then connection:Disconnect() end
    connection = RunService.Heartbeat:Connect(heartbeat)
end

function stopTrading()
    tradingEnabled = false
    if connection then connection:Disconnect() end
end

print("Advanced Trading ready; toggle on to begin.")
