-- Advanced Trading with Debug Prints
print("Advanced Trading script loaded")

-- Obsidian UI setup
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/deividcomsono/Obsidian/refs/heads/main/Library.lua"))()
local Window  = Library:CreateWindow({
    Title         = "Advanced Trading",
    Footer        = "v1.0.0",
    ToggleKeybind = Enum.KeyCode.RightControl,
    Center        = true,
    AutoShow      = true,
})

-- Trading tab & settings
local TradingTab    = Window:AddTab("Trading", "shopping-cart", "Automated resource trading")
local SettingsGroup = TradingTab:AddLeftGroupbox("Auto-Trade Settings", "settings")

-- Populate dropdown from Assets.Resources
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local resourcesFolder   = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Resources")
local resourceNames     = {}

for _, r in ipairs(resourcesFolder:GetChildren()) do
    table.insert(resourceNames, r.Name)
end
table.sort(resourceNames)

-- Selected resources (start empty)
local selectedResources = {}

SettingsGroup:AddDropdown("TradeResources", {
    Values   = resourceNames,
    Default  = {},
    Multi    = true,
    Text     = "Select Resources",
    Tooltip  = "Which resources to trade",
    Callback = function(selection)
        selectedResources = {}
        for _, name in ipairs(selection) do
            selectedResources[name] = true
        end
        print("Selected resources:", unpack(selection))
    end,
})

-- Toggles
local tradingEnabled  = false
local bypassFlowLimit = false

SettingsGroup:AddToggle("EnableAutoTrade", {
    Text    = "Enable Auto-Trade",
    Default = false,
    Callback = function(v)
        tradingEnabled = v
        print("Enable Auto-Trade set to", v)
        if v then startTrading() else stopTrading() end
    end,
})

SettingsGroup:AddToggle("BypassFlowLimit", {
    Text    = "Bypass Flow Limit",
    Default = false,
    Callback = function(v)
        bypassFlowLimit = v
        print("Bypass Flow Limit set to", v)
    end,
})

-- Services & state
local RunService    = game:GetService("RunService")
local StarterGui    = game:GetService("StarterGui")
local Players       = game:GetService("Players")
local GameManager   = workspace:WaitForChild("GameManager")
local player        = Players.LocalPlayer

-- Price data
local ResourcePrices = {
    Iron                = { Sell = 30400,      Buy = 38000     },
    Aluminum            = { Sell = 30400,      Buy = 38000     },
    Oil                 = { Sell = 32000,      Buy = 40000     },
    Phosphate           = { Sell = 33200,      Buy = 41500     },
    Copper              = { Sell = 33600,      Buy = 42000     },
    Chromium            = { Sell = 38000,      Buy = 47500     },
    Gold                = { Sell = 43200,      Buy = 54000     },
    Diamond             = { Sell = 69600,      Buy = 87000     },
    Tungsten            = { Sell = 76800,      Buy = 96000     },
    Titanium            = { Sell = 81600,      Buy = 102000    },
    Uranium             = { Sell = 420000,     Buy = 525000    },
    Steel               = { Sell = 60000,      Buy = 75000     },
    ["Consumer Goods"]  = { Sell = 65920,      Buy = 82400     },
    Fertilizer          = { Sell = 67200,      Buy = 84400     },
    ["Motor Parts"]     = { Sell = 73600,      Buy = 92000     },
    Electronics         = { Sell = 81600,      Buy = 102000    },
    ["Aircraft Parts"]  = { Sell = 83200,      Buy = 104000    },
    ["Enriched Uranium"]= { Sell = 96000000,   Buy = 120000000 },
}

local MIN_TRADE_VALUE   = 1
local TRADE_COOLDOWN    = 15
local TRADE_FLOW_WINDOW = 5

local lastTradeTime = {}
local aiList, aiIndex, connection

-- Helpers
local function sumFolder(folder)
    local total = 0
    for _, v in ipairs(folder:GetChildren()) do
        if v:IsA("NumberValue") then total += v.Value end
    end
    return total
end

local function isAICountry(c)
    local leader = c:FindFirstChild("Leader")
    return leader and leader.Value == (c.Name .. "AI")
end

local function getAICountries()
    local list = {}
    for _, c in ipairs(workspace.CountryData:GetChildren()) do
        if isAICountry(c) then
            table.insert(list, c.Name)
        end
    end
    print("Found AI countries:", unpack(list))
    return list
end

-- Core trading logic
local function sellResourceToAI(myCountry, resource, aiName)
    local name = resource.Name
    print(("sellResourceToAI called for %s to %s"):format(name, aiName))

    if not selectedResources[name] then
        print("  - resource not selected, skipping")
        return
    end

    local price = ResourcePrices[name]
    if not price then
        print("  - no price info for", name)
        return
    end

    local flowObj = resource:FindFirstChild("Flow")
    if not flowObj then
        print("  - no Flow object for", name)
        return
    end
    if flowObj.Value <= 0 then
        print("  - flow is zero for", name)
        return
    end

    local now = os.time()
    if lastTradeTime[name] and now - lastTradeTime[name] < TRADE_COOLDOWN then
        print("  - in cooldown for", name)
        return
    end

    local ai   = workspace.CountryData:FindFirstChild(aiName)
    local econ = ai and ai:FindFirstChild("Economy")
    if not econ then
        print("  - no Economy for AI", aiName)
        return
    end

    local balance = econ:FindFirstChild("Balance") and econ.Balance.Value or 0
    print("  - AI balance:", balance)
    if balance < 0 then
        print("  - AI in debt, skipping")
        return
    end

    local rev = econ:FindFirstChild("Revenue")  and sumFolder(econ.Revenue)  or 0
    local exp = econ:FindFirstChild("Expenses") and sumFolder(econ.Expenses) or 0
    local inc = rev - exp
    print(("  - AI income (rev-exp): %d - %d = %d"):format(rev, exp, inc))
    if inc <= 0 then
        print("  - AI net income <= 0, skipping")
        return
    end

    local cap = bypassFlowLimit and math.huge or (flowObj.Value * TRADE_FLOW_WINDOW)
    local mb  = balance / price.Sell
    local mi  = inc     / price.Sell
    local amt = math.min(cap, mb, mi)
    local tradeValue = amt * price.Sell

    print(("  - flowCap=%.2f, maxByBal=%.2f, maxByInc=%.2f, chosen amt=%.4f, tradeValue=%.2f")
        :format(cap, mb, mi, amt, tradeValue))

    if tradeValue < MIN_TRADE_VALUE then
        print("  - tradeValue <", MIN_TRADE_VALUE, "skipping")
        return
    end

    print(("  - sending trade: %s x %.4f to %s for $%.2f")
        :format(name, amt, aiName, tradeValue))
    GameManager.ManageAlliance:FireServer(aiName, "ResourceTrade", { name, "Sell", amt, 1, "Trade" })
    lastTradeTime[name] = now
end

local function sellAllToAI(country, aiName)
    print("sellAllToAI for AI", aiName)
    local resFolder = country:FindFirstChild("Resources")
    if not resFolder then
        print("  - no Resources folder in myCountry")
        return
    end
    for _, v in ipairs(resFolder:GetChildren()) do
        if v:IsA("NumberValue") then
            sellResourceToAI(country, v, aiName)
        end
    end
end

-- Heartbeat trading
local function heartbeat()
    if not tradingEnabled then return end

    local myCountry
    for _, c in ipairs(workspace.CountryData:GetChildren()) do
        if c:FindFirstChild("Leader") and c.Leader.Value == player.Name then
            myCountry = c
            break
        end
    end
    if not myCountry then
        print("heartbeat: myCountry not found")
        return
    end

    print(("heartbeat: aiIndex=%d, total=%d"):format(aiIndex, #aiList))
    if aiIndex > #aiList then
        stopTrading()
        StarterGui:SetCore("SendNotification", {
            Title    = "Trade Complete",
            Text     = "Finished trading with all available AI countries.",
            Duration = 5,
        })
        return
    end

    sellAllToAI(myCountry, aiList[aiIndex])
    aiIndex += 1
end

-- Control functions
function startTrading()
    print("startTrading called")
    aiList  = getAICountries()
    aiIndex = 1
    lastTradeTime = {}
    if connection then connection:Disconnect() end
    connection = RunService.Heartbeat:Connect(heartbeat)
end

function stopTrading()
    print("stopTrading called")
    tradingEnabled = false
    if connection then
        connection:Disconnect()
        connection = nil
    end
end
